Release "geoserver" does not exist. Installing it now.
NAME: geoserver
LAST DEPLOYED: Fri Jun 13 01:48:36 2025
NAMESPACE: geoserver
STATUS: pending-install
REVISION: 1
TEST SUITE: None
USER-SUPPLIED VALUES:
{}

COMPUTED VALUES:
global:
  affinity: {}
  extraEnv: []
  image:
    pullPolicy: IfNotPresent
    registry: ""
    tag: 2.27.1.0
  imagePullSecrets: []
  nodeSelector: {}
  securityContext: {}
  tolerations: []
ingress:
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
  enabled: false
  hosts:
  - host: geoserver.yourdomain.com
    paths:
    - path: /
      pathType: Prefix
  ingressClassName: nginx
  labels: {}
  tls:
  - hosts:
    - geoserver.yourdomain.com
    secretName: geo-tls
persistentVolumeClaims:
  geowebcache-data:
    accessModes:
    - ReadWriteMany
    claimName: geowebcache-data
    create: true
    size: 5Gi
    storageClassName: standard
  shared-data:
    accessModes:
    - ReadWriteMany
    claimName: shared-data
    create: true
    size: 5Gi
    storageClassName: standard
rabbitmq:
  advancedConfiguration: ""
  advancedConfigurationExistingSecret: ""
  affinity: {}
  args: []
  auth:
    enableLoopbackUser: false
    erlangCookie: secretcookie
    existingErlangSecret: ""
    existingPasswordSecret: ""
    existingSecretErlangKey: ""
    existingSecretPasswordKey: ""
    password: bitnami
    securePassword: true
    tls:
      autoGenerated: false
      caCertificate: ""
      enabled: false
      existingSecret: ""
      existingSecretFullChain: false
      failIfNoPeerCert: true
      overrideCaCertificate: ""
      serverCertificate: ""
      serverKey: ""
      sslOptionsPassword:
        enabled: false
        existingSecret: ""
        key: ""
        password: ""
      sslOptionsVerify: verify_peer
    updatePassword: false
    username: user
  automountServiceAccountToken: true
  clusterDomain: cluster.local
  clustering:
    addressType: hostname
    enabled: true
    forceBoot: false
    name: ""
    partitionHandling: autoheal
    rebalance: false
  command: []
  common:
    exampleValue: common-chart
    global:
      affinity: {}
      compatibility:
        openshift:
          adaptSecurityContext: auto
      defaultStorageClass: ""
      extraEnv: []
      image:
        pullPolicy: IfNotPresent
        registry: ""
        tag: 2.27.1.0
      imagePullSecrets: []
      imageRegistry: ""
      nodeSelector: {}
      security:
        allowInsecureImages: false
      securityContext: {}
      storageClass: ""
      tolerations: []
  commonAnnotations: {}
  commonLabels: {}
  communityPlugins: ""
  configuration: |-
    ## Username and password
    default_user = {{ .Values.auth.username }}
    {{- if and (not .Values.auth.securePassword) .Values.auth.password }}
    default_pass = {{ .Values.auth.password }}
    {{- end }}
    {{- if .Values.clustering.enabled }}
    ## Clustering
    ##
    cluster_name = {{ default (include "common.names.fullname" .) .Values.clustering.name }}
    cluster_formation.peer_discovery_backend  = rabbit_peer_discovery_k8s
    cluster_formation.k8s.host = kubernetes.default
    cluster_formation.k8s.address_type = {{ .Values.clustering.addressType }}
    {{- $svcName := printf "%s-%s" (include "common.names.fullname" .) (default "headless" .Values.servicenameOverride) }}
    cluster_formation.k8s.service_name = {{ $svcName }}
    cluster_formation.k8s.hostname_suffix = .{{ $svcName }}.{{ include "common.names.namespace" . }}.svc.{{ .Values.clusterDomain }}
    cluster_formation.node_cleanup.interval = 10
    cluster_formation.node_cleanup.only_log_warning = true
    cluster_partition_handling = {{ .Values.clustering.partitionHandling }}
    {{- end }}
    {{ if and .Values.clustering.enabled .Values.loadDefinition.enabled }}
    cluster_formation.target_cluster_size_hint = {{ .Values.replicaCount }}
    {{ end }}
    {{- if .Values.loadDefinition.enabled }}
    load_definitions = {{ .Values.loadDefinition.file }}
    {{- end }}
    # queue master locator
    queue_master_locator = {{ .Values.queue_master_locator }}
    # enable loopback user
    {{- if not (empty .Values.auth.username) }}
    loopback_users.{{ .Values.auth.username }} = {{ .Values.auth.enableLoopbackUser }}
    {{- else}}
    loopback_users.guest = {{ .Values.auth.enableLoopbackUser }}
    {{- end }}
    {{ template "rabbitmq.extraConfiguration" . }}
    {{- if .Values.auth.tls.enabled }}
    ssl_options.verify = {{ .Values.auth.tls.sslOptionsVerify }}
    listeners.ssl.default = {{ .Values.service.ports.amqpTls }}
    ssl_options.fail_if_no_peer_cert = {{ .Values.auth.tls.failIfNoPeerCert }}
    ssl_options.cacertfile = /opt/bitnami/rabbitmq/certs/ca_certificate.pem
    ssl_options.certfile = /opt/bitnami/rabbitmq/certs/server_certificate.pem
    ssl_options.keyfile = /opt/bitnami/rabbitmq/certs/server_key.pem
    {{- if .Values.auth.tls.sslOptionsPassword.enabled }}
    ssl_options.password = {{ include "common.secrets.passwords.manage" (dict "secret" .Values.auth.tls.sslOptionsPassword.existingSecret "key" .Values.auth.tls.sslOptionsPassword.key "providedValues" (list "auth.tls.sslOptionsPassword.password") "skipB64enc" true "failOnNew" false "context" $) }}
    {{- end }}
    {{- end }}
    {{- if .Values.ldap.enabled }}
    auth_backends.1.authn = ldap
    auth_backends.1.authz = {{ ternary "ldap" "internal" .Values.ldap.authorisationEnabled }}
    auth_backends.2 = internal
    {{- $host :=  list }}
    {{- $port :=  ternary 636 389 .Values.ldap.tls.enabled }}
    {{- if .Values.ldap.uri }}
    {{- $hostPort := get (urlParse .Values.ldap.uri) "host" }}
    {{- $host = list (index (splitList ":" $hostPort) 0) -}}
    {{- if (contains ":" $hostPort) }}
    {{- $port = index (splitList ":" $hostPort) 1 -}}
    {{- end }}
    {{- end }}
    {{- range $index, $server := concat $host .Values.ldap.servers }}
    auth_ldap.servers.{{ add $index 1 }} = {{ $server }}
    {{- end }}
    auth_ldap.port = {{ coalesce .Values.ldap.port $port }}
    {{- if or .Values.ldap.user_dn_pattern .Values.ldap.userDnPattern }}
    auth_ldap.user_dn_pattern = {{ coalesce .Values.ldap.user_dn_pattern .Values.ldap.userDnPattern }}
    {{- end }}
    {{- if .Values.ldap.basedn }}
    auth_ldap.dn_lookup_base = {{ .Values.ldap.basedn }}
    {{- end }}
    {{- if .Values.ldap.uidField }}
    auth_ldap.dn_lookup_attribute = {{ .Values.ldap.uidField }}
    {{- end }}
    {{- if .Values.ldap.binddn }}
    auth_ldap.dn_lookup_bind.user_dn = {{ .Values.ldap.binddn }}
    auth_ldap.dn_lookup_bind.password = {{ required "'ldap.bindpw' is required when 'ldap.binddn' is defined" .Values.ldap.bindpw }}
    {{- end }}
    {{- if .Values.ldap.tls.enabled }}
    auth_ldap.use_ssl = {{ not .Values.ldap.tls.startTls }}
    auth_ldap.use_starttls = {{ .Values.ldap.tls.startTls }}
    {{- if .Values.ldap.tls.CAFilename }}
    auth_ldap.ssl_options.cacertfile = {{ .Values.ldap.tls.certificatesMountPath }}/{{ .Values.ldap.tls.CAFilename }}
    {{- end }}
    {{- if .Values.ldap.tls.certFilename }}
    auth_ldap.ssl_options.certfile = {{ .Values.ldap.tls.certificatesMountPath }}/{{ .Values.ldap.tls.certFilename }}
    auth_ldap.ssl_options.keyfile = {{ .Values.ldap.tls.certificatesMountPath }}/{{ required "'ldap.tls.certKeyFilename' is required when 'ldap.tls.certFilename' is defined" .Values.ldap.tls.certKeyFilename }}
    {{- end }}
    {{- if .Values.ldap.tls.skipVerify }}
    auth_ldap.ssl_options.verify = verify_none
    auth_ldap.ssl_options.fail_if_no_peer_cert = false
    {{- else if .Values.ldap.tls.verify }}
    auth_ldap.ssl_options.verify = {{ .Values.ldap.tls.verify }}
    {{- end }}
    {{- end }}
    {{- end }}
    ## Prometheus metrics
    ##
    prometheus.tcp.port = {{ .Values.containerPorts.metrics }}
    {{- if .Values.memoryHighWatermark.enabled }}
    ## Memory Threshold
    ##
    {{- if (dig "limits" "memory" "" .Values.resources) }}
    total_memory_available_override_value = {{ include "rabbitmq.toBytes" (dig "limits" "memory" "" .Values.resources) }}
    {{- end }}
    {{- if (eq .Values.memoryHighWatermark.type "absolute") }}
    vm_memory_high_watermark.{{ .Values.memoryHighWatermark.type }} = {{ include "rabbitmq.toBytes" .Values.memoryHighWatermark.value }}
    {{- else if (eq .Values.memoryHighWatermark.type "relative") }}
    vm_memory_high_watermark.{{ .Values.memoryHighWatermark.type }} = {{ .Values.memoryHighWatermark.value }}
    {{- end }}
    {{- end }}
    {{- if .Values.tcpListenOptions.enabled }}
    ## TCP Listen Options
    ##
    tcp_listen_options.backlog = {{ .Values.tcpListenOptions.backlog }}
    tcp_listen_options.nodelay = {{ .Values.tcpListenOptions.nodelay }}
    tcp_listen_options.linger.on      = {{ .Values.tcpListenOptions.linger.lingerOn }}
    tcp_listen_options.linger.timeout = {{ .Values.tcpListenOptions.linger.timeout }}
    tcp_listen_options.keepalive = {{ .Values.tcpListenOptions.keepalive }}
    {{- end }}
  configurationExistingSecret: ""
  containerPorts:
    amqp: 5672
    amqpTls: 5671
    dist: 25672
    epmd: 4369
    manager: 15672
    metrics: 9419
  containerSecurityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
      - ALL
    enabled: true
    readOnlyRootFilesystem: true
    runAsGroup: 1001
    runAsNonRoot: true
    runAsUser: 1001
    seLinuxOptions: {}
    seccompProfile:
      type: RuntimeDefault
  customLivenessProbe: {}
  customReadinessProbe: {}
  customStartupProbe: {}
  diagnosticMode:
    args:
    - infinity
    command:
    - sleep
    enabled: false
  dnsConfig: {}
  dnsPolicy: ""
  enableServiceLinks: true
  extraConfiguration: |-
    #default_vhost = {{ .Release.Namespace }}-vhost
    #disk_free_limit.absolute = 50MB
  extraConfigurationExistingSecret: ""
  extraContainerPorts: []
  extraDeploy: []
  extraEnvVars: []
  extraEnvVarsCM: ""
  extraEnvVarsSecret: ""
  extraPlugins: rabbitmq_auth_backend_ldap
  extraSecrets: {}
  extraSecretsPrependReleaseName: false
  extraVolumeMounts: []
  extraVolumes: []
  featureFlags: ""
  fullnameOverride: ""
  global:
    affinity: {}
    compatibility:
      openshift:
        adaptSecurityContext: auto
    defaultStorageClass: ""
    extraEnv: []
    image:
      pullPolicy: IfNotPresent
      registry: ""
      tag: 2.27.1.0
    imagePullSecrets: []
    imageRegistry: ""
    nodeSelector: {}
    security:
      allowInsecureImages: false
    securityContext: {}
    storageClass: ""
    tolerations: []
  hostAliases: []
  hostPorts:
    amqp: ""
    amqpTls: ""
    manager: ""
    metrics: ""
  image:
    debug: false
    digest: ""
    pullPolicy: IfNotPresent
    pullSecrets: []
    registry: docker.io
    repository: bitnami/rabbitmq
    tag: 4.1.0-debian-12-r1
  ingress:
    annotations: {}
    enabled: false
    existingSecret: ""
    extraHosts: []
    extraPaths: []
    extraRules: []
    extraTls: []
    hostname: rabbitmq.local
    ingressClassName: ""
    path: /
    pathType: ImplementationSpecific
    secrets: []
    selfSigned: false
    tls: false
  initContainers: []
  initScripts: {}
  initScriptsCM: ""
  initScriptsSecret: ""
  kubeVersion: ""
  ldap:
    authorisationEnabled: false
    basedn: ""
    binddn: ""
    bindpw: ""
    enabled: false
    port: ""
    servers: []
    tls:
      CAFilename: ""
      certFilename: ""
      certKeyFilename: ""
      certificatesMountPath: /opt/bitnami/rabbitmq/ldap/certs
      certificatesSecret: ""
      enabled: false
      skipVerify: false
      startTls: false
      verify: verify_peer
    uidField: ""
    uri: ""
    userDnPattern: ""
  lifecycleHooks: {}
  livenessProbe:
    enabled: true
    failureThreshold: 6
    initialDelaySeconds: 120
    periodSeconds: 30
    successThreshold: 1
    timeoutSeconds: 20
  loadDefinition:
    enabled: false
    existingSecret: ""
    file: /app/load_definition.json
  logs: '-'
  maxAvailableSchedulers: ""
  memoryHighWatermark:
    enabled: false
    type: relative
    value: 0.4
  metrics:
    enabled: false
    plugins: rabbitmq_prometheus
    podAnnotations:
      prometheus.io/port: '{{ .Values.service.ports.metrics }}'
      prometheus.io/scrape: "true"
    prometheusRule:
      additionalLabels: {}
      enabled: false
      namespace: ""
      rules: []
    serviceMonitor:
      annotations: {}
      default:
        enabled: false
        honorLabels: false
        interval: 30s
        metricRelabelings: []
        relabelings: []
        scrapeTimeout: ""
      detailed:
        enabled: false
        family: []
        honorLabels: false
        interval: 30s
        metricRelabelings: []
        relabelings: []
        scrapeTimeout: ""
        vhost: []
      enabled: false
      honorLabels: false
      interval: 30s
      jobLabel: ""
      labels: {}
      metricRelabelings: []
      namespace: ""
      params: {}
      path: ""
      perObject:
        enabled: false
        honorLabels: false
        interval: 30s
        metricRelabelings: []
        relabelings: []
        scrapeTimeout: ""
      podTargetLabels: {}
      relabelings: []
      scrapeTimeout: ""
      selector: {}
      targetLabels: {}
  nameOverride: ""
  namespaceOverride: ""
  networkPolicy:
    addExternalClientAccess: true
    allowExternal: true
    allowExternalEgress: true
    enabled: true
    extraEgress: []
    extraIngress: []
    ingressNSMatchLabels: {}
    ingressNSPodMatchLabels: {}
    ingressPodMatchLabels: {}
    kubeAPIServerPorts:
    - 443
    - 6443
    - 8443
  nodeAffinityPreset:
    key: ""
    type: ""
    values: []
  nodeSelector: {}
  onlineSchedulers: ""
  pdb:
    create: true
    maxUnavailable: ""
    minAvailable: ""
  persistence:
    accessModes:
    - ReadWriteOnce
    annotations: {}
    enabled: false
    existingClaim: ""
    labels: {}
    mountPath: /opt/bitnami/rabbitmq/.rabbitmq/mnesia
    selector: {}
    size: 8Gi
    storageClass: standard
    subPath: ""
  persistentVolumeClaimRetentionPolicy:
    enabled: false
    whenDeleted: Retain
    whenScaled: Retain
  plugins: rabbitmq_management rabbitmq_peer_discovery_k8s
  podAffinityPreset: ""
  podAnnotations: {}
  podAntiAffinityPreset: soft
  podLabels: {}
  podManagementPolicy: OrderedReady
  podSecurityContext:
    enabled: true
    fsGroup: 1001
    fsGroupChangePolicy: Always
    supplementalGroups: []
    sysctls: []
  priorityClassName: ""
  queue_master_locator: min-masters
  rbac:
    create: true
    rules: []
  readinessProbe:
    enabled: true
    failureThreshold: 3
    initialDelaySeconds: 10
    periodSeconds: 30
    successThreshold: 1
    timeoutSeconds: 20
  replicaCount: 1
  resources: {}
  resourcesPreset: micro
  schedulerName: ""
  service:
    allocateLoadBalancerNodePorts: true
    annotations: {}
    annotationsHeadless: {}
    clusterIP: ""
    distPortEnabled: true
    epmdPortEnabled: true
    externalIPs: []
    externalTrafficPolicy: Cluster
    extraPorts: []
    extraPortsHeadless: []
    headless:
      annotations: {}
    labels: {}
    loadBalancerClass: ""
    loadBalancerIP: ""
    loadBalancerSourceRanges: []
    managerPortEnabled: true
    nodePorts:
      amqp: ""
      amqpTls: ""
      dist: ""
      epmd: ""
      manager: ""
      metrics: ""
    portEnabled: true
    portNames:
      amqp: amqp
      amqpTls: amqp-tls
      dist: dist
      epmd: epmd
      manager: http-stats
      metrics: metrics
    ports:
      amqp: 5672
      amqpTls: 5671
      dist: 25672
      epmd: 4369
      manager: 15672
      metrics: 9419
    sessionAffinity: None
    sessionAffinityConfig: {}
    trafficDistribution: PreferClose
    type: ClusterIP
  serviceAccount:
    annotations: {}
    automountServiceAccountToken: false
    create: true
    name: ""
  serviceBindings:
    enabled: false
  servicenameOverride: ""
  sidecars: []
  startupProbe:
    enabled: false
    failureThreshold: 3
    initialDelaySeconds: 10
    periodSeconds: 30
    successThreshold: 1
    timeoutSeconds: 20
  statefulsetAnnotations: {}
  statefulsetLabels: {}
  tcpListenOptions:
    backlog: 128
    enabled: true
    keepalive: false
    linger:
      lingerOn: true
      timeout: 0
    nodelay: true
  terminationGracePeriodSeconds: 120
  tolerations: []
  topologySpreadConstraints: []
  ulimitNofiles: "65535"
  updateStrategy:
    type: RollingUpdate
  usePasswordFiles: true
  volumePermissions:
    containerSecurityContext:
      runAsUser: 0
      seLinuxOptions: {}
    enabled: false
    image:
      digest: ""
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/os-shell
      tag: 12-debian-12-r45
    resources: {}
    resourcesPreset: nano
services:
  acl:
    affinity: {}
    enabled: false
    env:
    - name: ACL_USERS_ADMIN_PASSWORD
      value: s3cr3t
    - name: ACL_USERS_GEOSERVER_PASSWORD
      value: s3cr3t
    - name: GEOSERVER_BUS_ENABLED
      value: "true"
    hpa: {}
    image:
      image: geoservercloud/geoserver-acl
      pullPolicy: IfNotPresent
      registry: ""
      tag: 2.3.1
    imagePullSecrets: []
    livenessProbe: {}
    nodeSelector: {}
    readinessProbe: {}
    resources: {}
    securityContext: {}
    service:
      containerPort: 8080
      type: ClusterIP
    tolerations: []
    volumeMounts: []
    volumes: []
  admin:
    enabled: true
    env: []
    hpa: {}
    image:
      image: geoservercloud/geoserver-cloud-admin-server
      pullPolicy: IfNotPresent
      registry: ""
      tag: 2.27.1.0
    imagePullSecrets: []
    livenessProbe:
      httpGet:
        path: /actuator/health
      initialDelaySeconds: 30
      periodSeconds: 10
    readinessProbe:
      httpGet:
        path: /actuator/health
      initialDelaySeconds: 30
      periodSeconds: 10
    replicaCount: 1
    resources: {}
    securityContext: {}
    service:
      containerPort: 8080
      healthPort: 8080
      type: ClusterIP
    volumeMounts: []
    volumes: []
  config:
    affinity: {}
    enabled: true
    env: []
    git:
      branch: master
      http:
        password: ""
        passwordSecret:
          key: password
          name: ""
        username: ""
      protocol: http
      ssh:
        knownHosts: ""
        knownHostsSecret:
          key: known_hosts
          name: ""
        privateKey: ""
        privateKeySecret:
          key: id_rsa
          name: ""
      uri: https://github.com/geoserver/geoserver-cloud-config.git
    hpa: {}
    image:
      image: geoservercloud/geoserver-cloud-config
      pullPolicy: IfNotPresent
      registry: ""
      tag: 2.27.1.0
    imagePullSecrets: []
    livenessProbe: {}
    nodeSelector: {}
    readinessProbe: {}
    replicaCount: 1
    resources: {}
    securityContext: {}
    service:
      containerPort: 8080
      healthPort: 8081
      type: ClusterIP
    tolerations: []
    volumeMounts: []
    volumes: []
  discovery:
    affinity: {}
    enabled: true
    env: []
    hpa: {}
    image:
      image: geoservercloud/geoserver-cloud-discovery
      pullPolicy: IfNotPresent
      registry: ""
      tag: 2.27.1.0
    imagePullSecrets: []
    livenessProbe: {}
    nodeSelector: {}
    readinessProbe: {}
    replicaCount: 1
    resources: {}
    securityContext: {}
    service:
      containerPort: 8761
      healthPort: 8081
      type: ClusterIP
    tolerations: []
    volumeMounts: []
    volumes: []
  gateway:
    affinity: {}
    enabled: true
    env:
    - name: GEOSERVER_BASE_PATH
      value: /geoserver
    hpa: {}
    image:
      image: geoservercloud/geoserver-cloud-gateway
      pullPolicy: IfNotPresent
      registry: ""
      tag: 2.27.1.0
    imagePullSecrets: []
    livenessProbe:
      httpGet:
        path: /actuator/health
      initialDelaySeconds: 50
    nodeSelector: {}
    readinessProbe:
      httpGet:
        path: /actuator/health
      initialDelaySeconds: 50
    replicaCount: 1
    resources: {}
    securityContext: {}
    service:
      containerPort: 8080
      healthPort: 8081
      type: ClusterIP
    tolerations: []
    volumeMounts: []
    volumes: []
  gwc:
    affinity: {}
    enabled: true
    env:
    - name: GEOSERVER_DATA_DIR
      value: /opt/app/data_directory
    - name: GEOWEBCACHE_CACHE_DIR
      value: /data/geowebcache
    - name: SPRING_PROFILES_ACTIVE
      value: datadir
    hpa: {}
    image:
      image: geoservercloud/geoserver-cloud-gwc
      pullPolicy: IfNotPresent
      registry: ""
      tag: 2.27.1.0
    imagePullSecrets: []
    livenessProbe:
      httpGet:
        path: /actuator/health
      initialDelaySeconds: 50
    nodeSelector: {}
    readinessProbe:
      httpGet:
        path: /actuator/health
      initialDelaySeconds: 50
    replicaCount: 1
    resources: {}
    securityContext: {}
    service:
      containerPort: 8080
      healthPort: 8081
      type: ClusterIP
    tolerations: []
    volumeMounts:
    - mountPath: /opt/app/data_directory
      name: shared-data
    - mountPath: /data/geowebcache
      name: geowebcache-data
    volumes:
    - claimRef: shared-data
      name: shared-data
      type: pvc
    - claimRef: geowebcache-data
      name: geowebcache-data
      type: pvc
  rest:
    affinity: {}
    enabled: true
    env: []
    hpa: {}
    image:
      image: geoservercloud/geoserver-cloud-discovery
      pullPolicy: IfNotPresent
      registry: ""
      tag: 2.27.1.0
    imagePullSecrets: []
    livenessProbe:
      httpGet:
        path: /actuator/health
      initialDelaySeconds: 50
    nodeSelector: {}
    readinessProbe:
      httpGet:
        path: /actuator/health
      initialDelaySeconds: 50
    replicaCount: 1
    resources: {}
    securityContext: {}
    service:
      containerPort: 8080
      healthPort: 8081
      type: ClusterIP
    tolerations: []
    volumeMounts:
    - mountPath: /opt/app/data_directory
      name: shared-data
    volumes:
    - claimRef: shared-data
      name: shared-data
      type: pvc
  wcs:
    affinity: {}
    enabled: true
    env:
    - name: GEOSERVER_DATA_DIR
      value: /opt/app/data_directory
    - name: SPRING_PROFILES_ACTIVE
      value: datadir
    hpa: {}
    image:
      image: geoservercloud/geoserver-cloud-wcs
      pullPolicy: IfNotPresent
      registry: ""
      tag: 2.27.1.0
    imagePullSecrets: []
    livenessProbe:
      httpGet:
        path: /actuator/health
      initialDelaySeconds: 50
    nodeSelector: {}
    readinessProbe:
      httpGet:
        path: /actuator/health
      initialDelaySeconds: 50
    replicaCount: 1
    resources: {}
    securityContext: {}
    service:
      containerPort: 8080
      healthPort: 8081
      type: ClusterIP
    tolerations: []
    volumeMounts:
    - mountPath: /opt/app/data_directory
      name: shared-data
    volumes:
    - claimRef: shared-data
      name: shared-data
      type: pvc
  webui:
    affinity: {}
    enabled: true
    env:
    - name: GEOSERVER_DATA_DIR
      value: /opt/app/data_directory
    - name: GEOWEBCACHE_CACHE_DIR
      value: /data/geowebcache
    - name: SPRING_PROFILES_ACTIVE
      value: datadir
    - name: ACL_URL
      value: http://acl:8080/acl/api
    - name: ACL_USERNAME
      value: admin
    - name: ACL_PASSWORD
      value: s3cr3t
    hpa: {}
    image:
      image: geoservercloud/geoserver-cloud-webui
      pullPolicy: IfNotPresent
      registry: ""
      tag: 2.27.1.0
    imagePullSecrets: []
    livenessProbe:
      httpGet:
        path: /actuator/health
      initialDelaySeconds: 50
    nodeSelector: {}
    readinessProbe:
      httpGet:
        path: /actuator/health
      initialDelaySeconds: 50
    replicaCount: 1
    resources: {}
    securityContext: {}
    service:
      containerPort: 8080
      healthPort: 8081
      type: ClusterIP
    tolerations: []
    volumeMounts:
    - mountPath: /opt/app/data_directory
      name: shared-data
    - mountPath: /data/geowebcache
      name: geowebcache-data
    volumes:
    - claimRef: shared-data
      name: shared-data
      type: pvc
    - claimRef: geowebcache-data
      name: geowebcache-data
      type: pvc
  wfs:
    affinity: {}
    enabled: true
    env:
    - name: GEOSERVER_DATA_DIR
      value: /opt/app/data_directory
    - name: SPRING_PROFILES_ACTIVE
      value: datadir
    hpa:
      enabled: true
      maxReplicas: 5
      metrics:
      - resource:
          name: cpu
          target:
            averageUtilization: 80
            type: Utilization
        type: Resource
      minReplicas: 2
    image:
      image: geoservercloud/geoserver-cloud-wfs
      pullPolicy: IfNotPresent
      registry: ""
      tag: 2.27.1.0
    imagePullSecrets: []
    livenessProbe:
      httpGet:
        path: /actuator/health
      initialDelaySeconds: 50
    nodeSelector: {}
    readinessProbe:
      httpGet:
        path: /actuator/health
      initialDelaySeconds: 50
    replicaCount: 1
    resources: {}
    securityContext: {}
    service:
      containerPort: 8080
      healthPort: 8081
      type: ClusterIP
    tolerations: []
    volumeMounts:
    - mountPath: /opt/app/data_directory
      name: shared-data
    volumes:
    - claimRef: shared-data
      name: shared-data
      type: pvc
  wms:
    affinity: {}
    enabled: true
    env:
    - name: GEOSERVER_DATA_DIR
      value: /opt/app/data_directory
    - name: GEOWEBCACHE_CACHE_DIR
      value: /data/geowebcache
    - name: SPRING_PROFILES_ACTIVE
      value: datadir
    hpa:
      enabled: true
      maxReplicas: 5
      metrics:
      - resource:
          name: cpu
          target:
            averageUtilization: 75
            type: Utilization
        type: Resource
      - resource:
          name: memory
          target:
            averageUtilization: 65
            type: Utilization
        type: Resource
      minReplicas: 2
    image:
      image: geoservercloud/geoserver-cloud-wms
      pullPolicy: IfNotPresent
      registry: ""
      tag: 2.27.1.0
    imagePullSecrets: []
    livenessProbe:
      httpGet:
        path: /actuator/health
      initialDelaySeconds: 50
    nodeSelector: {}
    readinessProbe:
      httpGet:
        path: /actuator/health
      initialDelaySeconds: 50
    replicaCount: 1
    resources: {}
    securityContext: {}
    service:
      containerPort: 8080
      healthPort: 8081
      type: ClusterIP
    tolerations: []
    volumeMounts:
    - mountPath: /opt/app/data_directory
      name: shared-data
    - mountPath: /data/geowebcache
      name: geowebcache-data
    volumes:
    - claimRef: shared-data
      name: shared-data
      type: pvc
    - claimRef: geowebcache-data
      name: geowebcache-data
      type: pvc

HOOKS:
MANIFEST:
---
# Source: GeoserverCloud/charts/rabbitmq/templates/networkpolicy.yaml
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: geoserver-rabbitmq
  namespace: "geoserver"
  labels:
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: rabbitmq
    app.kubernetes.io/version: 4.1.0
    helm.sh/chart: rabbitmq-16.0.3
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/instance: geoserver
      app.kubernetes.io/name: rabbitmq
  policyTypes:
    - Ingress
    - Egress
  egress:
    - {}
  ingress:
    # Allow inbound connections to RabbitMQ
    - ports:
        - port: 4369
        - port: 5672
        - port: 5671
        - port: 25672
        - port: 15672
---
# Source: GeoserverCloud/charts/rabbitmq/templates/pdb.yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: geoserver-rabbitmq
  namespace: "geoserver"
  labels:
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: rabbitmq
    app.kubernetes.io/version: 4.1.0
    helm.sh/chart: rabbitmq-16.0.3
spec:
  maxUnavailable: 1
  selector:
    matchLabels:
      app.kubernetes.io/instance: geoserver
      app.kubernetes.io/name: rabbitmq
---
# Source: GeoserverCloud/charts/rabbitmq/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: geoserver-rabbitmq
  namespace: "geoserver"
  labels:
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: rabbitmq
    app.kubernetes.io/version: 4.1.0
    helm.sh/chart: rabbitmq-16.0.3
automountServiceAccountToken: false
secrets:
  - name: geoserver-rabbitmq
---
# Source: GeoserverCloud/charts/rabbitmq/templates/config-secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: geoserver-rabbitmq-config
  namespace: "geoserver"
  labels:
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: rabbitmq
    app.kubernetes.io/version: 4.1.0
    helm.sh/chart: rabbitmq-16.0.3
type: Opaque
data:
  rabbitmq.conf: |-
    IyMgVXNlcm5hbWUgYW5kIHBhc3N3b3JkCmRlZmF1bHRfdXNlciA9IHVzZXIKIyMgQ2x1c3RlcmluZwojIwpjbHVzdGVyX25hbWUgPSBnZW9zZXJ2ZXItcmFiYml0bXEKY2x1c3Rlcl9mb3JtYXRpb24ucGVlcl9kaXNjb3ZlcnlfYmFja2VuZCAgPSByYWJiaXRfcGVlcl9kaXNjb3ZlcnlfazhzCmNsdXN0ZXJfZm9ybWF0aW9uLms4cy5ob3N0ID0ga3ViZXJuZXRlcy5kZWZhdWx0CmNsdXN0ZXJfZm9ybWF0aW9uLms4cy5hZGRyZXNzX3R5cGUgPSBob3N0bmFtZQpjbHVzdGVyX2Zvcm1hdGlvbi5rOHMuc2VydmljZV9uYW1lID0gZ2Vvc2VydmVyLXJhYmJpdG1xLWhlYWRsZXNzCmNsdXN0ZXJfZm9ybWF0aW9uLms4cy5ob3N0bmFtZV9zdWZmaXggPSAuZ2Vvc2VydmVyLXJhYmJpdG1xLWhlYWRsZXNzLmdlb3NlcnZlci5zdmMuY2x1c3Rlci5sb2NhbApjbHVzdGVyX2Zvcm1hdGlvbi5ub2RlX2NsZWFudXAuaW50ZXJ2YWwgPSAxMApjbHVzdGVyX2Zvcm1hdGlvbi5ub2RlX2NsZWFudXAub25seV9sb2dfd2FybmluZyA9IHRydWUKY2x1c3Rlcl9wYXJ0aXRpb25faGFuZGxpbmcgPSBhdXRvaGVhbAoKIyBxdWV1ZSBtYXN0ZXIgbG9jYXRvcgpxdWV1ZV9tYXN0ZXJfbG9jYXRvciA9IG1pbi1tYXN0ZXJzCiMgZW5hYmxlIGxvb3BiYWNrIHVzZXIKbG9vcGJhY2tfdXNlcnMudXNlciA9IGZhbHNlCiNkZWZhdWx0X3Zob3N0ID0gZ2Vvc2VydmVyLXZob3N0CiNkaXNrX2ZyZWVfbGltaXQuYWJzb2x1dGUgPSA1ME1CCiMjIFByb21ldGhldXMgbWV0cmljcwojIwpwcm9tZXRoZXVzLnRjcC5wb3J0ID0gOTQxOQojIyBUQ1AgTGlzdGVuIE9wdGlvbnMKIyMKdGNwX2xpc3Rlbl9vcHRpb25zLmJhY2tsb2cgPSAxMjgKdGNwX2xpc3Rlbl9vcHRpb25zLm5vZGVsYXkgPSB0cnVlCnRjcF9saXN0ZW5fb3B0aW9ucy5saW5nZXIub24gICAgICA9IHRydWUKdGNwX2xpc3Rlbl9vcHRpb25zLmxpbmdlci50aW1lb3V0ID0gMAp0Y3BfbGlzdGVuX29wdGlvbnMua2VlcGFsaXZlID0gZmFsc2U=
---
# Source: GeoserverCloud/charts/rabbitmq/templates/secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: geoserver-rabbitmq
  namespace: "geoserver"
  labels:
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: rabbitmq
    app.kubernetes.io/version: 4.1.0
    helm.sh/chart: rabbitmq-16.0.3
type: Opaque
data:
  rabbitmq-password: "Yml0bmFtaQ=="
  rabbitmq-erlang-cookie: "c2VjcmV0Y29va2ll"
---
# Source: GeoserverCloud/templates/pvcs.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: geowebcache-data
  labels:
    app: geowebcache-data
spec:
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 5Gi
  storageClassName: standard
---
# Source: GeoserverCloud/templates/pvcs.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: shared-data
  labels:
    app: shared-data
spec:
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 5Gi
  storageClassName: standard
---
# Source: GeoserverCloud/charts/rabbitmq/templates/role.yaml
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: geoserver-rabbitmq-endpoint-reader
  namespace: "geoserver"
  labels:
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: rabbitmq
    app.kubernetes.io/version: 4.1.0
    helm.sh/chart: rabbitmq-16.0.3
rules:
  - apiGroups: [""]
    resources: ["endpoints"]
    verbs: ["get"]
  - apiGroups: [""]
    resources: ["events"]
    verbs: ["create"]
---
# Source: GeoserverCloud/charts/rabbitmq/templates/rolebinding.yaml
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: geoserver-rabbitmq-endpoint-reader
  namespace: "geoserver"
  labels:
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: rabbitmq
    app.kubernetes.io/version: 4.1.0
    helm.sh/chart: rabbitmq-16.0.3
subjects:
  - kind: ServiceAccount
    name: geoserver-rabbitmq
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: geoserver-rabbitmq-endpoint-reader
---
# Source: GeoserverCloud/charts/rabbitmq/templates/svc-headless.yaml
apiVersion: v1
kind: Service
metadata:
  name: geoserver-rabbitmq-headless
  namespace: "geoserver"
  labels:
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: rabbitmq
    app.kubernetes.io/version: 4.1.0
    helm.sh/chart: rabbitmq-16.0.3
spec:
  clusterIP: None
  ports:
    - name: epmd
      port: 4369
      targetPort: epmd
    - name: amqp
      port: 5672
      targetPort: amqp
    - name: dist
      port: 25672
      targetPort: dist
    - name: http-stats
      port: 15672
      targetPort: stats
  selector:
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/name: rabbitmq
  publishNotReadyAddresses: true
  trafficDistribution: PreferClose
---
# Source: GeoserverCloud/charts/rabbitmq/templates/svc.yaml
apiVersion: v1
kind: Service
metadata:
  name: geoserver-rabbitmq
  namespace: "geoserver"
  labels:
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: rabbitmq
    app.kubernetes.io/version: 4.1.0
    helm.sh/chart: rabbitmq-16.0.3
spec:
  type: ClusterIP
  sessionAffinity: None
  ports:
    - name: amqp
      port: 5672
      targetPort: amqp
      nodePort: null
    - name: epmd
      port: 4369
      targetPort: epmd
      nodePort: null
    - name: dist
      port: 25672
      targetPort: dist
      nodePort: null
    - name: http-stats
      port: 15672
      targetPort: stats
      nodePort: null
  selector:
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/name: rabbitmq
---
# Source: GeoserverCloud/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: admin
  labels:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: admin
spec:
  type: ClusterIP
  selector:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: admin
  ports:
    - name: http
      port: 8080
      targetPort: 8080
---
# Source: GeoserverCloud/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: config
  labels:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: config
spec:
  type: ClusterIP
  selector:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: config
  ports:
    - name: http
      port: 8080
      targetPort: 8080
    - name: health
      port: 8081
      targetPort: 8081
---
# Source: GeoserverCloud/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: discovery
  labels:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: discovery
spec:
  type: ClusterIP
  selector:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: discovery
  ports:
    - name: http
      port: 8761
      targetPort: 8761
    - name: health
      port: 8081
      targetPort: 8081
---
# Source: GeoserverCloud/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: gateway
  labels:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: gateway
spec:
  type: ClusterIP
  selector:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: gateway
  ports:
    - name: http
      port: 8080
      targetPort: 8080
    - name: health
      port: 8081
      targetPort: 8081
---
# Source: GeoserverCloud/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: gwc
  labels:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: gwc
spec:
  type: ClusterIP
  selector:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: gwc
  ports:
    - name: http
      port: 8080
      targetPort: 8080
    - name: health
      port: 8081
      targetPort: 8081
---
# Source: GeoserverCloud/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: rest
  labels:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: rest
spec:
  type: ClusterIP
  selector:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: rest
  ports:
    - name: http
      port: 8080
      targetPort: 8080
    - name: health
      port: 8081
      targetPort: 8081
---
# Source: GeoserverCloud/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: wcs
  labels:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: wcs
spec:
  type: ClusterIP
  selector:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: wcs
  ports:
    - name: http
      port: 8080
      targetPort: 8080
    - name: health
      port: 8081
      targetPort: 8081
---
# Source: GeoserverCloud/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: webui
  labels:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: webui
spec:
  type: ClusterIP
  selector:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: webui
  ports:
    - name: http
      port: 8080
      targetPort: 8080
    - name: health
      port: 8081
      targetPort: 8081
---
# Source: GeoserverCloud/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: wfs
  labels:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: wfs
spec:
  type: ClusterIP
  selector:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: wfs
  ports:
    - name: http
      port: 8080
      targetPort: 8080
    - name: health
      port: 8081
      targetPort: 8081
---
# Source: GeoserverCloud/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: wms
  labels:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: wms
spec:
  type: ClusterIP
  selector:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: wms
  ports:
    - name: http
      port: 8080
      targetPort: 8080
    - name: health
      port: 8081
      targetPort: 8081
---
# Source: GeoserverCloud/templates/deployment-stateful.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: admin
  labels:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: admin
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: admin
  template:
    metadata:
      labels:
        helm.sh/chart: GeoserverCloud-0.0.1
        app.kubernetes.io/name: GeoserverCloud
        app.kubernetes.io/instance: geoserver
        app.kubernetes.io/version: "2.27.1.0"
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/name: admin
    spec:
      
      
      containers:
        - name: admin
          image: geoservercloud/geoserver-cloud-admin-server:2.27.1.0
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
          env:
          
            - name: RABBITMQ_HOST
              value: "geoserver-rabbitmq"
            - name: RABBITMQ_PORT
              value: "5672"
            - name: RABBITMQ_USER
              value: "user"
            - name: RABBITMQ_PASSWORD
              value: "bitnami"
          resources:
            {}
          readinessProbe: 
          
            
            httpGet:
              path: /actuator/health
              port: 8080
            initialDelaySeconds: 30
            periodSeconds: 10
          livenessProbe:
          
            
            httpGet:
              path: /actuator/health
              port: 8080
            initialDelaySeconds: 30
            periodSeconds: 10
---
# Source: GeoserverCloud/templates/deployment-stateful.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: config
  labels:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: config
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: config
  template:
    metadata:
      labels:
        helm.sh/chart: GeoserverCloud-0.0.1
        app.kubernetes.io/name: GeoserverCloud
        app.kubernetes.io/instance: geoserver
        app.kubernetes.io/version: "2.27.1.0"
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/name: config
    spec:
      
      
      containers:
        - name: config
          image: geoservercloud/geoserver-cloud-config:2.27.1.0
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
          env:
          
            - name: SPRING_PROFILES_ACTIVE
              value: git
            - name: CONFIG_GIT_BASEDIR
              value: /tmp/git_config
            - name: CONFIG_NATIVE_PATH
              value: /tmp/config
            - name: XDG_CONFIG_HOME
              value: /tmp
            - name: SPRING_CLOUD_CONFIG_SERVER_GIT_URI
              value: "https://github.com/geoserver/geoserver-cloud-config.git"
            - name: SPRING_CLOUD_CONFIG_SERVER_GIT_DEFAULT_LABEL
              value: "master"
            - name: RABBITMQ_HOST
              value: "geoserver-rabbitmq"
            - name: RABBITMQ_PORT
              value: "5672"
            - name: RABBITMQ_USER
              value: "user"
            - name: RABBITMQ_PASSWORD
              value: "bitnami"
          resources:
            {}
---
# Source: GeoserverCloud/templates/deployment-stateful.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: gateway
  labels:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: gateway
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: gateway
  template:
    metadata:
      labels:
        helm.sh/chart: GeoserverCloud-0.0.1
        app.kubernetes.io/name: GeoserverCloud
        app.kubernetes.io/instance: geoserver
        app.kubernetes.io/version: "2.27.1.0"
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/name: gateway
    spec:
      
      
      containers:
        - name: gateway
          image: geoservercloud/geoserver-cloud-gateway:2.27.1.0
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
          env:
          
            - name: GEOSERVER_BASE_PATH
              value: /geoserver
            - name: RABBITMQ_HOST
              value: "geoserver-rabbitmq"
            - name: RABBITMQ_PORT
              value: "5672"
            - name: RABBITMQ_USER
              value: "user"
            - name: RABBITMQ_PASSWORD
              value: "bitnami"
          resources:
            {}
          readinessProbe: 
          
            
            httpGet:
              path: /actuator/health
              port: 8081
            initialDelaySeconds: 50
          livenessProbe:
          
            
            httpGet:
              path: /actuator/health
              port: 8081
            initialDelaySeconds: 50
---
# Source: GeoserverCloud/templates/deployment-stateful.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: gwc
  labels:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: gwc
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: gwc
  template:
    metadata:
      labels:
        helm.sh/chart: GeoserverCloud-0.0.1
        app.kubernetes.io/name: GeoserverCloud
        app.kubernetes.io/instance: geoserver
        app.kubernetes.io/version: "2.27.1.0"
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/name: gwc
    spec:
      
      
      containers:
        - name: gwc
          image: geoservercloud/geoserver-cloud-gwc:2.27.1.0
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
          env:
          
            - name: GEOSERVER_DATA_DIR
              value: /opt/app/data_directory
            - name: GEOWEBCACHE_CACHE_DIR
              value: /data/geowebcache
            - name: SPRING_PROFILES_ACTIVE
              value: datadir
            - name: RABBITMQ_HOST
              value: "geoserver-rabbitmq"
            - name: RABBITMQ_PORT
              value: "5672"
            - name: RABBITMQ_USER
              value: "user"
            - name: RABBITMQ_PASSWORD
              value: "bitnami"
          resources:
            {}
          readinessProbe: 
          
            
            httpGet:
              path: /actuator/health
              port: 8081
            initialDelaySeconds: 50
          livenessProbe:
          
            
            httpGet:
              path: /actuator/health
              port: 8081
            initialDelaySeconds: 50
          volumeMounts:
            
            - name: shared-data
              mountPath: /opt/app/data_directory
            - name: geowebcache-data
              mountPath: /data/geowebcache
      volumes:
        
          - name: shared-data
            persistentVolumeClaim:
              claimName:
                shared-data
          - name: geowebcache-data
            persistentVolumeClaim:
              claimName:
                geowebcache-data
---
# Source: GeoserverCloud/templates/deployment-stateful.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rest
  labels:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: rest
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: rest
  template:
    metadata:
      labels:
        helm.sh/chart: GeoserverCloud-0.0.1
        app.kubernetes.io/name: GeoserverCloud
        app.kubernetes.io/instance: geoserver
        app.kubernetes.io/version: "2.27.1.0"
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/name: rest
    spec:
      
      
      containers:
        - name: rest
          image: geoservercloud/geoserver-cloud-discovery:2.27.1.0
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
          env:
          
            - name: RABBITMQ_HOST
              value: "geoserver-rabbitmq"
            - name: RABBITMQ_PORT
              value: "5672"
            - name: RABBITMQ_USER
              value: "user"
            - name: RABBITMQ_PASSWORD
              value: "bitnami"
          resources:
            {}
          readinessProbe: 
          
            
            httpGet:
              path: /actuator/health
              port: 8081
            initialDelaySeconds: 50
          livenessProbe:
          
            
            httpGet:
              path: /actuator/health
              port: 8081
            initialDelaySeconds: 50
          volumeMounts:
            
            - name: shared-data
              mountPath: /opt/app/data_directory
      volumes:
        
          - name: shared-data
            persistentVolumeClaim:
              claimName:
                shared-data
---
# Source: GeoserverCloud/templates/deployment-stateful.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wcs
  labels:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: wcs
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: wcs
  template:
    metadata:
      labels:
        helm.sh/chart: GeoserverCloud-0.0.1
        app.kubernetes.io/name: GeoserverCloud
        app.kubernetes.io/instance: geoserver
        app.kubernetes.io/version: "2.27.1.0"
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/name: wcs
    spec:
      
      
      containers:
        - name: wcs
          image: geoservercloud/geoserver-cloud-wcs:2.27.1.0
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
          env:
          
            - name: GEOSERVER_DATA_DIR
              value: /opt/app/data_directory
            - name: SPRING_PROFILES_ACTIVE
              value: datadir
            - name: RABBITMQ_HOST
              value: "geoserver-rabbitmq"
            - name: RABBITMQ_PORT
              value: "5672"
            - name: RABBITMQ_USER
              value: "user"
            - name: RABBITMQ_PASSWORD
              value: "bitnami"
          resources:
            {}
          readinessProbe: 
          
            
            httpGet:
              path: /actuator/health
              port: 8081
            initialDelaySeconds: 50
          livenessProbe:
          
            
            httpGet:
              path: /actuator/health
              port: 8081
            initialDelaySeconds: 50
          volumeMounts:
            
            - name: shared-data
              mountPath: /opt/app/data_directory
      volumes:
        
          - name: shared-data
            persistentVolumeClaim:
              claimName:
                shared-data
---
# Source: GeoserverCloud/templates/deployment-stateful.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webui
  labels:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: webui
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: webui
  template:
    metadata:
      labels:
        helm.sh/chart: GeoserverCloud-0.0.1
        app.kubernetes.io/name: GeoserverCloud
        app.kubernetes.io/instance: geoserver
        app.kubernetes.io/version: "2.27.1.0"
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/name: webui
    spec:
      
      
      containers:
        - name: webui
          image: geoservercloud/geoserver-cloud-webui:2.27.1.0
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
          env:
          
            - name: GEOSERVER_DATA_DIR
              value: /opt/app/data_directory
            - name: GEOWEBCACHE_CACHE_DIR
              value: /data/geowebcache
            - name: SPRING_PROFILES_ACTIVE
              value: datadir
            - name: ACL_URL
              value: http://acl:8080/acl/api
            - name: ACL_USERNAME
              value: admin
            - name: ACL_PASSWORD
              value: s3cr3t
            - name: RABBITMQ_HOST
              value: "geoserver-rabbitmq"
            - name: RABBITMQ_PORT
              value: "5672"
            - name: RABBITMQ_USER
              value: "user"
            - name: RABBITMQ_PASSWORD
              value: "bitnami"
          resources:
            {}
          readinessProbe: 
          
            
            httpGet:
              path: /actuator/health
              port: 8081
            initialDelaySeconds: 50
          livenessProbe:
          
            
            httpGet:
              path: /actuator/health
              port: 8081
            initialDelaySeconds: 50
          volumeMounts:
            
            - name: shared-data
              mountPath: /opt/app/data_directory
            - name: geowebcache-data
              mountPath: /data/geowebcache
      volumes:
        
          - name: shared-data
            persistentVolumeClaim:
              claimName:
                shared-data
          - name: geowebcache-data
            persistentVolumeClaim:
              claimName:
                geowebcache-data
---
# Source: GeoserverCloud/templates/deployment-stateful.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wfs
  labels:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: wfs
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: wfs
  template:
    metadata:
      labels:
        helm.sh/chart: GeoserverCloud-0.0.1
        app.kubernetes.io/name: GeoserverCloud
        app.kubernetes.io/instance: geoserver
        app.kubernetes.io/version: "2.27.1.0"
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/name: wfs
    spec:
      
      
      containers:
        - name: wfs
          image: geoservercloud/geoserver-cloud-wfs:2.27.1.0
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
          env:
          
            - name: GEOSERVER_DATA_DIR
              value: /opt/app/data_directory
            - name: SPRING_PROFILES_ACTIVE
              value: datadir
            - name: RABBITMQ_HOST
              value: "geoserver-rabbitmq"
            - name: RABBITMQ_PORT
              value: "5672"
            - name: RABBITMQ_USER
              value: "user"
            - name: RABBITMQ_PASSWORD
              value: "bitnami"
          resources:
            {}
          readinessProbe: 
          
            
            httpGet:
              path: /actuator/health
              port: 8081
            initialDelaySeconds: 50
          livenessProbe:
          
            
            httpGet:
              path: /actuator/health
              port: 8081
            initialDelaySeconds: 50
          volumeMounts:
            
            - name: shared-data
              mountPath: /opt/app/data_directory
      volumes:
        
          - name: shared-data
            persistentVolumeClaim:
              claimName:
                shared-data
---
# Source: GeoserverCloud/templates/deployment-stateful.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wms
  labels:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: wms
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: wms
  template:
    metadata:
      labels:
        helm.sh/chart: GeoserverCloud-0.0.1
        app.kubernetes.io/name: GeoserverCloud
        app.kubernetes.io/instance: geoserver
        app.kubernetes.io/version: "2.27.1.0"
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/name: wms
    spec:
      
      
      containers:
        - name: wms
          image: geoservercloud/geoserver-cloud-wms:2.27.1.0
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
          env:
          
            - name: GEOSERVER_DATA_DIR
              value: /opt/app/data_directory
            - name: GEOWEBCACHE_CACHE_DIR
              value: /data/geowebcache
            - name: SPRING_PROFILES_ACTIVE
              value: datadir
            - name: RABBITMQ_HOST
              value: "geoserver-rabbitmq"
            - name: RABBITMQ_PORT
              value: "5672"
            - name: RABBITMQ_USER
              value: "user"
            - name: RABBITMQ_PASSWORD
              value: "bitnami"
          resources:
            {}
          readinessProbe: 
          
            
            httpGet:
              path: /actuator/health
              port: 8081
            initialDelaySeconds: 50
          livenessProbe:
          
            
            httpGet:
              path: /actuator/health
              port: 8081
            initialDelaySeconds: 50
          volumeMounts:
            
            - name: shared-data
              mountPath: /opt/app/data_directory
            - name: geowebcache-data
              mountPath: /data/geowebcache
      volumes:
        
          - name: shared-data
            persistentVolumeClaim:
              claimName:
                shared-data
          - name: geowebcache-data
            persistentVolumeClaim:
              claimName:
                geowebcache-data
---
# Source: GeoserverCloud/templates/hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: wfs
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: wfs
  minReplicas: 2
  maxReplicas: 5
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 80
---
# Source: GeoserverCloud/templates/hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: wms
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: wms
  minReplicas: 2
  maxReplicas: 5
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 75
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 65
---
# Source: GeoserverCloud/charts/rabbitmq/templates/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: geoserver-rabbitmq
  namespace: "geoserver"
  labels:
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: rabbitmq
    app.kubernetes.io/version: 4.1.0
    helm.sh/chart: rabbitmq-16.0.3
spec:
  serviceName: geoserver-rabbitmq-headless
  podManagementPolicy: OrderedReady
  replicas: 1
  updateStrategy:
    type: RollingUpdate
  selector:
    matchLabels:
      app.kubernetes.io/instance: geoserver
      app.kubernetes.io/name: rabbitmq
  template:
    metadata:
      labels:
        app.kubernetes.io/instance: geoserver
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/name: rabbitmq
        app.kubernetes.io/version: 4.1.0
        helm.sh/chart: rabbitmq-16.0.3
      annotations:
        checksum/config: 24171f11fc6e5ed75fe2b582bae4ad99b051f8b4a1f2009ea9367c882fc09132
        checksum/secret: c535f0951f594cc9c4ce854231240e42f9318af2951faa181d0602a26d1fb544
    spec:
      
      serviceAccountName: geoserver-rabbitmq
      affinity:
        podAffinity:
          
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/instance: geoserver
                    app.kubernetes.io/name: rabbitmq
                topologyKey: kubernetes.io/hostname
              weight: 1
        nodeAffinity:
          
      automountServiceAccountToken: true
      securityContext:
        fsGroup: 1001
        fsGroupChangePolicy: Always
        supplementalGroups: []
        sysctls: []
      terminationGracePeriodSeconds: 120
      enableServiceLinks: true
      initContainers:
        - name: prepare-plugins-dir
          image: docker.io/bitnami/rabbitmq:4.1.0-debian-12-r1
          imagePullPolicy: "IfNotPresent"
          resources:
            limits:
              cpu: 375m
              ephemeral-storage: 2Gi
              memory: 384Mi
            requests:
              cpu: 250m
              ephemeral-storage: 50Mi
              memory: 256Mi
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
              - ALL
            readOnlyRootFilesystem: true
            runAsGroup: 1001
            runAsNonRoot: true
            runAsUser: 1001
            seLinuxOptions: {}
            seccompProfile:
              type: RuntimeDefault
          command:
            - /bin/bash
          args:
            - -ec
            - |
              #!/bin/bash

              . /opt/bitnami/scripts/liblog.sh

              info "Copying plugins dir to empty dir"
              # In order to not break the possibility of installing custom plugins, we need
              # to make the plugins directory writable, so we need to copy it to an empty dir volume
              cp -r --preserve=mode /opt/bitnami/rabbitmq/plugins/ /emptydir/app-plugins-dir
          volumeMounts:
            - name: empty-dir
              mountPath: /emptydir
      containers:
        - name: rabbitmq
          image: docker.io/bitnami/rabbitmq:4.1.0-debian-12-r1
          imagePullPolicy: "IfNotPresent"
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
              - ALL
            readOnlyRootFilesystem: true
            runAsGroup: 1001
            runAsNonRoot: true
            runAsUser: 1001
            seLinuxOptions: {}
            seccompProfile:
              type: RuntimeDefault
          lifecycle:
            preStop:
              exec:
                command:
                  - /bin/bash
                  - -ec
                  - |
                    if [[ -f /opt/bitnami/scripts/rabbitmq/nodeshutdown.sh ]]; then
                        /opt/bitnami/scripts/rabbitmq/nodeshutdown.sh -t "120" -d "false"
                    else
                        rabbitmqctl stop_app
                    fi
          env:
            - name: BITNAMI_DEBUG
              value: "false"
            - name: MY_POD_IP
              valueFrom:
                fieldRef:
                  fieldPath: status.podIP
            - name: MY_POD_NAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: MY_POD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
            - name: RABBITMQ_FORCE_BOOT
              value: "no"
            - name: RABBITMQ_NODE_NAME
              value: "rabbit@$(MY_POD_NAME).geoserver-rabbitmq-headless.$(MY_POD_NAMESPACE).svc.cluster.local"
            - name: RABBITMQ_UPDATE_PASSWORD
              value: "no"
            - name: RABBITMQ_MNESIA_DIR
              value: "/opt/bitnami/rabbitmq/.rabbitmq/mnesia/$(RABBITMQ_NODE_NAME)"
            - name: RABBITMQ_LDAP_ENABLE
              value: "no"
            - name: RABBITMQ_LOGS
              value: "-"
            - name: RABBITMQ_ULIMIT_NOFILES
              value: "65535"
            - name: RABBITMQ_USE_LONGNAME
              value: "true"
            - name: RABBITMQ_ERL_COOKIE_FILE
              value: /opt/bitnami/rabbitmq/secrets/rabbitmq-erlang-cookie
            - name: RABBITMQ_LOAD_DEFINITIONS
              value: "no"
            - name: RABBITMQ_DEFINITIONS_FILE
              value: "/app/load_definition.json"
            - name: RABBITMQ_SECURE_PASSWORD
              value: "yes"
            - name: RABBITMQ_USERNAME
              value: "user"
            - name: RABBITMQ_PASSWORD_FILE
              value: /opt/bitnami/rabbitmq/secrets/rabbitmq-password
            - name: RABBITMQ_PLUGINS
              value: "rabbitmq_management, rabbitmq_peer_discovery_k8s, rabbitmq_auth_backend_ldap"
          envFrom:
          ports:
            - name: amqp
              containerPort: 5672
            - name: dist
              containerPort: 25672
            - name: stats
              containerPort: 15672
            - name: epmd
              containerPort: 4369
            - name: metrics
              containerPort: 9419
          livenessProbe:
            failureThreshold: 6
            initialDelaySeconds: 120
            periodSeconds: 30
            successThreshold: 1
            timeoutSeconds: 20
            exec:
              command:
                - /bin/bash
                - -ec
                - curl -f --user user:$(< $RABBITMQ_PASSWORD_FILE) 127.0.0.1:15672/api/health/checks/virtual-hosts
          readinessProbe:
            failureThreshold: 3
            initialDelaySeconds: 10
            periodSeconds: 30
            successThreshold: 1
            timeoutSeconds: 20
            exec:
              command:
                - /bin/bash
                - -ec
                - curl -f --user user:$(< $RABBITMQ_PASSWORD_FILE) 127.0.0.1:15672/api/health/checks/local-alarms
          resources:
            limits:
              cpu: 375m
              ephemeral-storage: 2Gi
              memory: 384Mi
            requests:
              cpu: 250m
              ephemeral-storage: 50Mi
              memory: 256Mi
          volumeMounts:
            - name: configuration
              mountPath: /bitnami/rabbitmq/conf
            - name: empty-dir
              mountPath: /tmp
              subPath: tmp-dir
            - name: empty-dir
              mountPath: /opt/bitnami/rabbitmq/etc/rabbitmq
              subPath: app-conf-dir
            - name: empty-dir
              mountPath: /opt/bitnami/rabbitmq/var/lib/rabbitmq
              subPath: app-tmp-dir
            - name: empty-dir
              mountPath: /opt/bitnami/rabbitmq/.rabbitmq/
              subPath: app-erlang-cookie
            - name: empty-dir
              mountPath: /opt/bitnami/rabbitmq/var/log/rabbitmq
              subPath: app-logs-dir
            - name: empty-dir
              mountPath: /opt/bitnami/rabbitmq/plugins
              subPath: app-plugins-dir
            - name: data
              mountPath: /opt/bitnami/rabbitmq/.rabbitmq/mnesia
            - name: rabbitmq-secrets
              mountPath: /opt/bitnami/rabbitmq/secrets
      volumes:
        - name: empty-dir
          emptyDir: {}
        - name: configuration
          projected:
            sources:
              - secret:
                  name: geoserver-rabbitmq-config
        - name: rabbitmq-secrets
          projected:
            sources:
              - secret:
                  name: geoserver-rabbitmq
              - secret:
                  name: geoserver-rabbitmq
        - name: data
          emptyDir: {}
---
# Source: GeoserverCloud/templates/deployment-stateful.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: discovery
  labels:
    helm.sh/chart: GeoserverCloud-0.0.1
    app.kubernetes.io/name: GeoserverCloud
    app.kubernetes.io/instance: geoserver
    app.kubernetes.io/version: "2.27.1.0"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: discovery
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: discovery
  serviceName: discovery
  template:
    metadata:
      labels:
        helm.sh/chart: GeoserverCloud-0.0.1
        app.kubernetes.io/name: GeoserverCloud
        app.kubernetes.io/instance: geoserver
        app.kubernetes.io/version: "2.27.1.0"
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/name: discovery
    spec:
      
      
      containers:
        - name: discovery
          image: geoservercloud/geoserver-cloud-discovery:2.27.1.0
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8761
          env:
          
            - name: RABBITMQ_HOST
              value: "geoserver-rabbitmq"
            - name: RABBITMQ_PORT
              value: "5672"
            - name: RABBITMQ_USER
              value: "user"
            - name: RABBITMQ_PASSWORD
              value: "bitnami"
          resources:
            {}

